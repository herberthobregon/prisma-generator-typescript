import { mkdirSync, readFileSync, writeFileSync } from "node:fs";

import generatorHelper from "@prisma/generator-helper";
import path, { dirname } from "node:path";
import z from "zod";
import { ConfigSchema } from "./src/config.zod.js";
import { CUSTOM_TYPES, getEnumTs, getModelTs } from "./src/ts.schema.js";
import { getEnumZod, getModelZod } from "./src/zod.schema.js";

// Need to use default export for ESM compatibility
const { generatorHandler } = generatorHelper;

generatorHandler({
	onManifest() {
		return {
			prettyName: "Typescript Interfaces",
			defaultOutput: "interfaces.ts",
		};
	},
	async onGenerate(options) {
		const configUntrusted: z.infer<typeof ConfigSchema> = {
			enumPrefix: "",
			enumSuffix: "",
			modelPrefix: "",
			modelSuffix: "",
			typePrefix: "",
			typeSuffix: "",
			headerComment: "This file was auto-generated by prisma-generator-typescript-schema",
			modelType: "interface",
			enumType: "stringUnion",
			dateType: "Date",
			bigIntType: "bigint",
			decimalType: "Decimal",
			bytesType: "Buffer",
			namespaceType: "PrismaJson",
			...options.generator.config,
			// Booleans go here since in the base config they are strings
			optionalRelations: options.generator.config.optionalRelations !== "false", // Default true
			omitRelations: options.generator.config.omitRelations === "true", // Default false
			optionalNullables: options.generator.config.optionalNullables === "true", // Default false
			prettier: options.generator.config.prettier === "true", // Default false
		};
		const configResult = ConfigSchema.safeParse(configUntrusted);
		if (!configResult.success) {
			const errors = configResult.error.issues.map((issue) => {
				const value = options.generator.config[issue.path[0]];
				return `Invalid ${issue.path[0]}: ${value as string}`;
			});
			throw new Error(`${errors.join("\n")}`);
		}
		const config: z.infer<typeof ConfigSchema> = configResult.data;

		// validateConfig(config);

		const datamodel = options.dmmf.datamodel;
		const models = datamodel.models;
		const enums = datamodel.enums;
		const types = datamodel.types;

		const usedCustomTypes = new Set<keyof typeof CUSTOM_TYPES>();

		const enumNameMap = new Map<string, string>(enums.map((e) => [e.name, `${config.enumPrefix}${e.name}${config.enumSuffix}`]));
		const modelNameMap = new Map<string, string>(models.map((m) => [m.name, `${config.modelPrefix}${m.name}${config.modelSuffix}`]));
		const typeNameMap = new Map<string, string>(types.map((t) => [t.name, `${config.typePrefix}${t.name}${config.typeSuffix}`]));

		const enumsTs = enums.map((e) => getEnumTs(config, e, enumNameMap));
		// Types and Models are essentially the same thing, so we can run both through getModelTs
		const modelsTs = [...models, ...types].map((m) => getModelTs(config, m, modelNameMap, enumNameMap, typeNameMap, usedCustomTypes));
		const customTypesTs = Array.from(usedCustomTypes).map((t) => CUSTOM_TYPES[t]);

		let ts = [...enumsTs, ...modelsTs, ...customTypesTs].join("\n\n") + "\n";

		if (config.headerComment) {
			const headerContent = config.headerComment
				.split("\n")
				.map((line) => `// ${line}`)
				.join("\n");
			ts = `${headerContent}\n\n${ts}`;
		}
		if (config.namespace) {
			ts = `export namespace ${config.namespace} {\n${ts}\n}`;
		}

		if (config.prefixCode) {
			const file = readFileSync(config.prefixCode, "utf8");
			ts = `${file}\n${ts}`;
		}
		if (config.suffixCode) {
			const file = readFileSync(config.suffixCode, "utf8");
			ts = `${ts}\n${file}`;
		}

		let prettier: typeof import("prettier") | undefined;
		if (config.prettier) {
			try {
				prettier = await import("prettier");
			} catch {
				throw new Error("Unable import Prettier. Is it installed?");
			}
		}

		if (config.zodOutput) {
			const enumsZod = enums.map((e) => getEnumZod(config, e, enumNameMap));
			const modelsZod = [...models, ...types].map((m) => getModelZod(config, m, modelNameMap, enumNameMap, typeNameMap));

			let zodTs = `import { z } from "zod";\n\n${[...enumsZod, ...modelsZod].join("\n\n")}\n`;

			if (prettier) {
				zodTs = await prettier.format(zodTs, { parser: "typescript" });
			}

			const outputFile = options.generator.output?.value as string;
			const outputDir = dirname(outputFile);
			mkdirSync(outputDir, { recursive: true });
			const safePath = path.join(outputDir, config.zodOutput);
			console.log("Writing Zod schema to", safePath);
			writeFileSync(safePath, zodTs);
		}

		if (prettier) {
			ts = await prettier.format(ts, { parser: "typescript" });
		}

		const outputFile = options.generator.output?.value as string;
		const outputDir = dirname(outputFile);
		mkdirSync(outputDir, { recursive: true });
		writeFileSync(outputFile, ts);
	},
});
